<?php

/** @var \Madar\StockAvailability\Block\GoogleMaps $block */
$product = $block->getProduct();
if (!$product) {
    return;
}

$mapsApiKey = $block->getReferrerApiKey();
?>

<script>
    (function() {
        const apiKey = <?= json_encode($mapsApiKey, JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_QUOT | JSON_HEX_AMP); ?>;

        if (!apiKey) {
            console.warn('[StoreAvailability] Google Maps API key is missing');
            return;
        }

        if (window.google && window.google.maps) {
            window._mapsApiReady = Promise.resolve(window.google.maps);
            return;
        }

        if (!window._mapsApiReady) {
            window._mapsApiReady = new Promise(function(resolve, reject) {
                const callbackName = '__onGoogleMapsReady';
                const previousCallback = window[callbackName];

                window[callbackName] = function() {
                    if (typeof previousCallback === 'function') {
                        try {
                            previousCallback();
                        } catch (callbackError) {
                            console.error(callbackError);
                        }
                    }

                    resolve(window.google.maps);
                };

                if (document.querySelector('script[src*="maps.googleapis.com/maps/api/js"]')) {
                    return;
                }

                const script = document.createElement('script');
                script.src = 'https://maps.googleapis.com/maps/api/js'
                    + '?key=' + apiKey
                    + '&libraries=places'
                    + '&callback=' + callbackName;
                script.async = true;
                script.defer = true;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
    })();
</script>

<div x-data='storeAvailabilityComponent({ apiKey: <?= json_encode($mapsApiKey, JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP); ?> })' x-init="init()" class="store-availability-section">
    <h3 class="text-lg font-semibold mb-4"><?= $escaper->escapeHtml(__('Check availability at stores near you')) ?></h3>

    <!-- Location Search Input -->
    <div class="mb-4">
        <label for="city-search" class="block text-sm font-medium text-gray-700 mb-2">
            <?= $escaper->escapeHtml(__('Select or enter your city or region')) ?>
        </label>

        <!-- Manual Location Input -->
        <div class="flex flex-col sm:flex-row gap-2">
            <input
                type="text"
                id="city-search"
                x-ref="cityInput"
                x-model="cityName"
                autocomplete="off"
                @keyup.enter="searchByLocation(cityName)"
                placeholder="<?= $escaper->escapeHtmlAttr(__('Or type city or region name (Arabic or English)')) ?>"
                class="flex-1 form-input border border-neutral-200 rounded-md px-3 py-2" />
            <button
                @click="searchByLocation(cityName)"
                :disabled="!cityName.trim() || isLoading"
                class="btn btn-primary">
                <?= $escaper->escapeHtml(__('Search')) ?>
            </button>
            <button
                @click="useCurrentLocation()"
                :disabled="isLoading"
                class="btn btn-secondary px-4 py-2 border border-neutral-200 rounded-md hover:bg-gray-50 disabled:opacity-50 w-full sm:w-auto">
                üìç
            </button>
        </div>
        <p class="text-xs text-gray-500 mt-1">
            <?= $escaper->escapeHtml(__('Type your city or region name to search nearby stores')) ?>
        </p>
    </div>

    <!-- Loading State -->
    <div x-show="isLoading" class="text-center py-6">
        <div class="animate-spin w-6 h-6 border-2 border-neutral-200 border-t-primary rounded-full mx-auto mb-2"></div>
        <p class="text-gray-600" x-text="loadingMessage"><?= $escaper->escapeHtml(__('Searching...')) ?></p>
    </div>

    <!-- Search Results Info -->
    <div x-show="searchPerformed && !isLoading && searchedLocation" class="mb-4 p-3 bg-blue-50 rounded-lg">
        <p class="text-sm text-blue-800">
            <strong><?= $escaper->escapeHtml(__('Showing stores near:')) ?></strong>
            <span x-text="searchedLocation"></span>
        </p>
    </div>

    <div x-show="searchPerformed && !isLoading && availableStores.length > 0" class="mb-4 grid grid-cols-1 sm:grid-cols-2 gap-4">
        <div class="bg-green-50 p-3 rounded-lg text-center">
            <div class="text-2xl font-bold text-green-700" x-text="getStoreCountByStatus('in_stock')"></div>
            <div class="text-sm text-green-600"><?= $escaper->escapeHtml(__('Stores with immediate stock')) ?></div>
        </div>
        <div class="bg-yellow-50 p-3 rounded-lg text-center">
            <div class="text-2xl font-bold text-yellow-700" x-text="getStoreCountByStatus('backorder')"></div>
            <div class="text-sm text-yellow-600"><?= $escaper->escapeHtml(__('Stores can order from warehouse')) ?></div>
        </div>
    </div>

    <!-- Available Stores List -->
    <div x-show="!isLoading && availableStores.length > 0" class="space-y-3">
        <h4 class="font-medium text-gray-900 flex items-center gap-2">
            <svg class="w-5 h-5 text-green-600" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
            </svg>
            <?= $escaper->escapeHtml(__('Available at these stores')) ?>
            <span class="text-sm font-normal text-gray-600" x-text="'(' + availableStores.length + ' found)'"></span>
        </h4>

        <!-- Group stores by stock status -->
        <div x-show="getStoresByStatus('in_stock').length > 0" class="mb-4">
            <h5 class="text-sm font-medium text-gray-700 mb-2"><?= $escaper->escapeHtml(__('In Stock at Store')) ?></h5>
            <template x-for="store in getStoresByStatus('in_stock')" :key="store.source_code">
                <div class="border border-neutral-200 rounded-lg p-4 shadow-sm hover:shadow-md transition-shadow mb-2">
                    <div class="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-3">
                        <div class="flex-1">
                            <h5 class="font-medium text-gray-900 mb-1" x-text="store.source_name"></h5>
                            <!--<p class="text-sm text-gray-600 mb-2" x-show="store.phone">
                                üìû <span x-text="store.phone"></span>
                            </p>-->
                            <p class="text-sm text-gray-500">
                                üìç <span x-text="store.distance"></span> km away
                            </p>
                        </div>
                        <div class="text-left sm:text-right sm:ml-4">
                            <div class="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800 mb-2">
                                <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                </svg>
                                <?= $escaper->escapeHtml(__('In Stock')) ?>
                            </div>
                            <div>
                                <button
                                    @click="getDirections(store)"
                                    class="text-xs text-blue-600 hover:underline">
                                    <?= $escaper->escapeHtml(__('Get Directions')) ?>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </template>
        </div>

        <div x-show="getStoresByStatus('backorder').length > 0">
            <h5 class="text-sm font-medium text-gray-700 mb-2"><?= $escaper->escapeHtml(__('Available for Order (Ships from Warehouse)')) ?></h5>
            <template x-for="store in getStoresByStatus('backorder')" :key="store.source_code">
                <div class="border border-neutral-200 rounded-lg p-4 bg-white shadow-sm hover:shadow-md transition-shadow mb-2">
                    <div class="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-3">
                        <div class="flex-1">
                            <h5 class="font-medium text-gray-900 mb-1" x-text="store.source_name"></h5>
                            <!--
                            <p class="text-sm text-gray-600 mb-2" x-show="store.phone">
                                üìû <span x-text="store.phone"></span>
                            </p>-->
                            <p class="text-sm text-gray-500">
                                üìç <span x-text="store.distance"></span> km away
                            </p>
                            <p class="text-xs text-gray-500 italic mt-1">
                                <?= $escaper->escapeHtml(__('This location can order this item from our warehouse')) ?>
                            </p>
                        </div>
                        <div class="text-left sm:text-right sm:ml-4">
                            <div class="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800 mb-2">
                                <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>
                                </svg>
                                <?= $escaper->escapeHtml(__('Backorder')) ?>
                            </div>
                            <div>
                                <button
                                    @click="getDirections(store)"
                                    class="text-xs text-blue-600 hover:underline">
                                    <?= $escaper->escapeHtml(__('Get Directions')) ?>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </template>
        </div>
    </div>

    <!-- No Available Stores Message -->
    <div x-show="!isLoading && searchPerformed && availableStores.length === 0" class="text-center py-8 text-gray-500 bg-gray-50 rounded-lg">
        <svg class="w-12 h-12 mx-auto mb-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"></path>
        </svg>
        <p class="text-lg font-medium mb-2"><?= $escaper->escapeHtml(__('No stores found with this product in stock')) ?></p>
        <p class="text-sm">
            <?= $escaper->escapeHtml(__('This product is not available at stores near')) ?>
            <span x-text="searchedLocation" class="font-medium"></span>
        </p>
        <p class="text-xs mt-2"><?= $escaper->escapeHtml(__('Try searching for a different city or check online availability.')) ?></p>
    </div>
</div>

<script>
    function storeAvailabilityComponent(config = {}) {
        return {
            apiKey: config.apiKey || '',
            mapsApi: null,
            geocoder: null,
            placesService: null,
            mapsHelperElement: null,
            mapsLoadError: false,
            availableStores: [],
            searchPerformed: false,
            isLoading: false,
            cityName: '',
            searchedLocation: '',
            loadingMessage: '<?= $escaper->escapeJs(__('Searching...')) ?>',
            autocomplete: null,
            locationListener: null,
            privateContentListener: null,
            lastSearchedCoords: null,
            hasBootstrappedFromDelivery: false,

            init() {
                console.log('Store availability component initialized');

                if (this.apiKey) {
                    this.ensureMapsApi()
                        .then(() => {
                            this.setupAutocomplete();
                        })
                        .catch((error) => {
                            console.error('Failed to prepare Google Maps services', error);
                        });
                } else {
                    console.warn('[StoreAvailability] Google Maps API key missing ‚Äì geocoding will be unavailable');
                }

                this.bindToDeliveryLocationUpdates();

                this.$nextTick(() => {
                    this.tryBootstrapFromExistingSelection();
                });
            },

            async ensureMapsApi() {
                if (this.mapsApi) {
                    return this.mapsApi;
                }

                if (!window._mapsApiReady) {
                    this.mapsLoadError = true;
                    return null;
                }

                try {
                    const maps = await window._mapsApiReady;
                    this.mapsApi = maps;
                    this.mapsLoadError = false;

                    if (!this.geocoder) {
                        this.geocoder = new maps.Geocoder();
                    }

                    if (!this.placesService && maps.places) {
                        this.mapsHelperElement = this.mapsHelperElement || document.createElement('div');
                        this.placesService = new maps.places.PlacesService(this.mapsHelperElement);
                    }

                    this.setupAutocomplete();

                    return maps;
                } catch (error) {
                    this.mapsLoadError = true;
                    console.error('[StoreAvailability] Failed to load Google Maps API', error);
                    return null;
                }
            },

            setupAutocomplete() {
                if (!this.mapsApi || !this.mapsApi.places || !this.$refs.cityInput) {
                    return;
                }

                if (this.autocomplete) {
                    return;
                }

                try {
                    this.autocomplete = new this.mapsApi.places.Autocomplete(this.$refs.cityInput, {
                        componentRestrictions: { country: 'sa' },
                        fields: ['address_components', 'formatted_address', 'geometry', 'name'],
                        types: ['geocode']
                    });

                    this.autocomplete.addListener('place_changed', () => {
                        this.handleAutocompleteSelection();
                    });
                } catch (error) {
                    console.error('[StoreAvailability] Failed to initialise autocomplete', error);
                }
            },

            handleAutocompleteSelection() {
                if (!this.autocomplete) {
                    return;
                }

                const place = typeof this.autocomplete.getPlace === 'function'
                    ? this.autocomplete.getPlace()
                    : null;

                if (!place || !place.geometry || !place.geometry.location) {
                    const fallback = (this.cityName || '').trim();
                    if (fallback) {
                        this.searchByLocation(fallback);
                    }
                    return;
                }

                const location = place.geometry.location;
                const latValue = typeof location.lat === 'function' ? location.lat() : location.lat;
                const lngValue = typeof location.lng === 'function' ? location.lng() : location.lng;

                const lat = this.parseCoordinate(latValue);
                const lng = this.parseCoordinate(lngValue);

                if (lat === null || lng === null) {
                    return;
                }

                const label = this.composePlaceLabel(place) || this.formatCoordinatesLabel(lat, lng);

                this.refreshStoresForCoordinates(lat, lng, label);
            },

            composePlaceLabel(place) {
                if (!place || typeof place !== 'object') {
                    return '';
                }

                const formatted = (place.formatted_address || '').trim();
                const name = (place.name || '').trim();

                if (formatted && name) {
                    if (formatted.toLowerCase().startsWith(name.toLowerCase())) {
                        return formatted;
                    }

                    return `${name}, ${formatted}`;
                }

                return formatted || name || '';
            },

            bindToDeliveryLocationUpdates() {
                if (!this.locationListener) {
                    this.locationListener = (event) => this.handleExternalLocationUpdate(event);
                    window.addEventListener('madar:location-updated', this.locationListener);
                }

                if (!this.privateContentListener) {
                    this.privateContentListener = () => this.tryBootstrapFromExistingSelection();
                    window.addEventListener('private-content-loaded', this.privateContentListener);
                }

                if (this.$el) {
                    this.$el.addEventListener(
                        'alpine:destroy',
                        () => {
                            if (this.locationListener) {
                                window.removeEventListener('madar:location-updated', this.locationListener);
                                this.locationListener = null;
                            }

                            if (this.privateContentListener) {
                                window.removeEventListener('private-content-loaded', this.privateContentListener);
                                this.privateContentListener = null;
                            }
                        },
                        { once: true }
                    );
                }
            },

            tryBootstrapFromExistingSelection() {
                if (this.hasBootstrappedFromDelivery) {
                    return;
                }

                const snapshot = this.getExistingDeliveryLocation();

                if (!snapshot) {
                    return;
                }

                this.hasBootstrappedFromDelivery = true;

                this.refreshStoresForCoordinates(snapshot.lat, snapshot.lng, snapshot.label);
            },

            getExistingDeliveryLocation() {
                let branchData = null;

                if (typeof Alpine !== 'undefined' && typeof Alpine.store === 'function') {
                    const customerStore = Alpine.store('customerData');

                    if (customerStore && customerStore.data && customerStore.data['delivery-branch']) {
                        branchData = customerStore.data['delivery-branch'];
                    }
                }

                const hyvaData = window.hyva && window.hyva.mapData ? window.hyva.mapData : null;

                const branchLat = branchData && typeof branchData === 'object'
                    ? (branchData.customer_latitude ?? branchData.latitude ?? branchData.lat)
                    : undefined;
                const branchLng = branchData && typeof branchData === 'object'
                    ? (branchData.customer_longitude ?? branchData.longitude ?? branchData.lng)
                    : undefined;

                const lat = this.parseCoordinate(branchLat);
                const lng = this.parseCoordinate(branchLng);

                const fallbackLat = lat === null && hyvaData ? this.parseCoordinate(hyvaData.latitude) : lat;
                const fallbackLng = lng === null && hyvaData ? this.parseCoordinate(hyvaData.longitude) : lng;

                const resolvedLat = fallbackLat;
                const resolvedLng = fallbackLng;

                if (resolvedLat === null || resolvedLng === null) {
                    return null;
                }

                const label =
                    this.buildLocationLabel(
                        {
                            branch: branchData || {},
                            shipping: {},
                            prefill: hyvaData && hyvaData.prefill ? hyvaData.prefill : {},
                        },
                        resolvedLat,
                        resolvedLng
                    ) ||
                    (branchData && branchData.selected_branch_name) ||
                    (hyvaData && hyvaData.selected_branch_name) ||
                    this.formatCoordinatesLabel(resolvedLat, resolvedLng);

                return {
                    lat: resolvedLat,
                    lng: resolvedLng,
                    label,
                };
            },

            handleExternalLocationUpdate(event) {
                if (!event || !event.detail) {
                    return;
                }

                const { lat, lng, label } = this.extractLocationFromDetail(event.detail);

                if (lat === null || lng === null) {
                    return;
                }

                const displayLabel = label || this.formatCoordinatesLabel(lat, lng);

                if (
                    this.lastSearchedCoords &&
                    this.coordinatesAreEqual(
                        this.lastSearchedCoords.lat,
                        this.lastSearchedCoords.lng,
                        lat,
                        lng
                    )
                ) {
                    this.searchedLocation = displayLabel;

                    if (!this.cityName) {
                        this.cityName = displayLabel;
                    }

                    this.hasBootstrappedFromDelivery = true;

                    return;
                }

                this.hasBootstrappedFromDelivery = true;
                this.refreshStoresForCoordinates(lat, lng, displayLabel);
            },

            extractLocationFromDetail(detail) {
                if (!detail || typeof detail !== 'object') {
                    return { lat: null, lng: null, label: '' };
                }

                const branch = detail.branch || {};
                const shipping = detail.shipping_address || {};
                const prefill = detail.prefill || {};

                const lat = this.parseCoordinate(
                    branch.customer_latitude ??
                    branch.latitude ??
                    branch.lat ??
                    shipping.latitude ??
                    prefill.latitude ??
                    prefill.lat
                );
                const lng = this.parseCoordinate(
                    branch.customer_longitude ??
                    branch.longitude ??
                    branch.lng ??
                    shipping.longitude ??
                    prefill.longitude ??
                    prefill.lng
                );

                const label = this.buildLocationLabel({ branch, shipping, prefill }, lat, lng);

                return { lat, lng, label };
            },

            buildLocationLabel(context, lat, lng) {
                if (!context || typeof context !== 'object') {
                    if (Number.isFinite(lat) && Number.isFinite(lng)) {
                        return this.formatCoordinatesLabel(lat, lng);
                    }

                    return '';
                }

                const labelParts = [];

                const pushUnique = (value) => {
                    const normalized = (value || '').toString().trim();

                    if (normalized && !labelParts.includes(normalized)) {
                        labelParts.push(normalized);
                    }
                };

                const shipping = context.shipping || {};

                if (shipping && typeof shipping === 'object') {
                    pushUnique(shipping.district);
                    pushUnique(shipping.city);

                    if (shipping.region) {
                        if (typeof shipping.region === 'object') {
                            pushUnique(shipping.region.region);
                            pushUnique(shipping.region.region_code);
                        } else {
                            pushUnique(shipping.region);
                        }
                    }
                }

                const prefill = context.prefill || {};

                if (!labelParts.length && prefill && typeof prefill === 'object') {
                    pushUnique(prefill.district);
                    pushUnique(prefill.city);
                    pushUnique(prefill.region);
                }

                const branch = context.branch || {};

                if (!labelParts.length && branch && typeof branch === 'object') {
                    pushUnique(branch.selected_branch_name);
                    pushUnique(branch.branch_name);
                }

                if (labelParts.length) {
                    return labelParts.join(', ');
                }

                if (Number.isFinite(lat) && Number.isFinite(lng)) {
                    return this.formatCoordinatesLabel(lat, lng);
                }

                return '';
            },

            parseCoordinate(value) {
                if (typeof value === 'number' && Number.isFinite(value)) {
                    return value;
                }

                if (typeof value === 'string') {
                    const parsed = parseFloat(value);

                    if (!Number.isNaN(parsed)) {
                        return parsed;
                    }
                }

                return null;
            },

            coordinatesAreEqual(lat1, lng1, lat2, lng2) {
                const epsilon = 0.0001;

                return (
                    Math.abs(lat1 - lat2) < epsilon &&
                    Math.abs(lng1 - lng2) < epsilon
                );
            },

            formatCoordinatesLabel(lat, lng) {
                if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
                    return '';
                }

                return `${lat.toFixed(4)}, ${lng.toFixed(4)}`;
            },

            async refreshStoresForCoordinates(lat, lng, label, options = {}) {
                const normalizedLat = this.parseCoordinate(lat);
                const normalizedLng = this.parseCoordinate(lng);

                if (normalizedLat === null || normalizedLng === null) {
                    return;
                }

                const maintainLoading = Boolean(options.maintainLoading);
                const keepInput = Boolean(options.keepInput);
                const force = Boolean(options.force);
                const customMessage = options.loadingMessage;

                const displayLabel = (label || '').toString().trim()
                    || this.formatCoordinatesLabel(normalizedLat, normalizedLng);

                if (!force && this.lastSearchedCoords && this.coordinatesAreEqual(
                    this.lastSearchedCoords.lat,
                    this.lastSearchedCoords.lng,
                    normalizedLat,
                    normalizedLng
                )) {
                    this.searchedLocation = displayLabel;

                    if (!keepInput) {
                        this.cityName = displayLabel;
                    }

                    return;
                }

                if (!maintainLoading) {
                    this.isLoading = true;
                }

                this.loadingMessage = customMessage
                    || '<?= $escaper->escapeJs(__('Searching for available stores...')) ?>';
                this.searchPerformed = true;
                this.availableStores = [];
                this.searchedLocation = displayLabel;

                if (!keepInput) {
                    this.cityName = displayLabel;
                }

                this.lastSearchedCoords = { lat: normalizedLat, lng: normalizedLng };

                try {
                    await this.searchAvailableStores(normalizedLat, normalizedLng);
                } finally {
                    if (!maintainLoading) {
                        this.isLoading = false;
                    }
                }
            },

            // Add new method to filter stores by status
            getStoresByStatus(status) {
                return this.availableStores.filter(store => store.stock_status === status);
            },

            // Add method to count stores by type
            getStoreCountByStatus(status) {
                return this.getStoresByStatus(status).length;
            },

            async searchByLocation(placeName) {
                if (!placeName || !placeName.trim()) {
                    alert('<?= $escaper->escapeJs(__('Please enter a city or region name')) ?>');
                    return;
                }

                const trimmedName = placeName.trim();

                this.isLoading = true;
                this.searchPerformed = true;
                this.availableStores = [];
                this.searchedLocation = trimmedName;
                this.loadingMessage = '<?= $escaper->escapeJs(__('Finding location...')) ?>';
                this.cityName = trimmedName;

                try {
                    if (!this.apiKey) {
                        throw new Error('Google Maps API key not configured');
                    }

                    const maps = await this.ensureMapsApi();

                    if (!maps || this.mapsLoadError) {
                        throw new Error('Google Maps API unavailable');
                    }

                    let coordinates = await this.geocodeCity(trimmedName);

                    if (!coordinates) {
                        console.warn(`No city match found for ${trimmedName}, trying region search...`);
                        this.loadingMessage = '<?= $escaper->escapeJs(__('Finding region...')) ?>';
                        coordinates = await this.geocodeRegion(trimmedName);
                    }

                    if (coordinates) {
                        const resolvedLabel = (coordinates.label || '').toString().trim() || trimmedName;
                        this.cityName = resolvedLabel;
                        await this.refreshStoresForCoordinates(coordinates.lat, coordinates.lng, resolvedLabel, {
                            maintainLoading: true,
                            keepInput: true,
                            force: true
                        });
                    } else {
                        this.availableStores = [];
                        alert('<?= $escaper->escapeJs(__('Location not found. Please check the spelling and try again.')) ?>');
                    }

                } catch (error) {
                    console.error('Error searching by location:', error);
                    this.availableStores = [];
                    alert('<?= $escaper->escapeJs(__('Error searching for stores. Please try again.')) ?>');
                } finally {
                    this.isLoading = false;
                }
            },

            async geocodeCity(cityName) {
                try {
                    await this.ensureMapsApi();

                    const queries = [
                        `${cityName} city, Saudi Arabia`,
                        `${cityName}, Saudi Arabia`
                    ];

                    const geocodeResults = await this.geocodeWithQueries(queries);
                    const cityCandidate = this.resolveBestCandidate(geocodeResults, cityName, { preferCity: true });

                    if (cityCandidate) {
                        return cityCandidate;
                    }

                    const placesResults = await this.findPlaces(queries, { preferCity: true });
                    return this.resolveBestCandidate(placesResults, cityName, { preferCity: true });
                } catch (error) {
                    console.error('Geocoding error:', error);
                    return null;
                }
            },

            async geocodeRegion(regionName) {
                try {
                    await this.ensureMapsApi();

                    const queries = [
                        `${regionName} region, Saudi Arabia`,
                        `${regionName} province, Saudi Arabia`,
                        `${regionName} governorate, Saudi Arabia`,
                        `${regionName}, Saudi Arabia`
                    ];

                    const geocodeResults = await this.geocodeWithQueries(queries);
                    const regionCandidate = this.resolveBestCandidate(geocodeResults, regionName, { preferRegion: true });

                    if (regionCandidate) {
                        return regionCandidate;
                    }

                    const placesResults = await this.findPlaces(queries, { preferRegion: true });
                    return this.resolveBestCandidate(placesResults, regionName, { preferRegion: true });
                } catch (error) {
                    console.error('Geocoding region error:', error);
                    return null;
                }
            },

            async geocodeWithQueries(queries) {
                if (!this.geocoder || !Array.isArray(queries)) {
                    return [];
                }

                const combinedResults = [];

                for (const query of queries) {
                    const results = await this.runGeocode({
                        address: query,
                        componentRestrictions: { country: 'SA' }
                    });

                    if (results.length) {
                        combinedResults.push(...results);
                    }

                    if (combinedResults.length) {
                        break;
                    }
                }

                return combinedResults;
            },

            async findPlaces(queries, preference = {}) {
                if (!this.placesService || !Array.isArray(queries)) {
                    return [];
                }

                const combinedResults = [];

                for (const query of queries) {
                    const results = await this.runPlacesQuery(query);

                    if (results.length) {
                        combinedResults.push(...results);
                    }

                    if (combinedResults.length) {
                        break;
                    }
                }

                return combinedResults;
            },

            runGeocode(request) {
                return new Promise((resolve) => {
                    if (!this.geocoder) {
                        resolve([]);
                        return;
                    }

                    this.geocoder.geocode(request, (results, status) => {
                        if (status === 'OK' && Array.isArray(results)) {
                            resolve(results);
                        } else {
                            resolve([]);
                        }
                    });
                });
            },

            runPlacesQuery(query) {
                return new Promise((resolve) => {
                    if (!this.placesService) {
                        resolve([]);
                        return;
                    }

                    const request = {
                        query,
                        fields: ['name', 'geometry', 'formatted_address', 'types']
                    };

                    this.placesService.findPlaceFromQuery(request, (results, status) => {
                        const maps = this.mapsApi;
                        const okStatus = maps && maps.places ? maps.places.PlacesServiceStatus.OK : 'OK';

                        if (status === okStatus && Array.isArray(results)) {
                            resolve(results);
                        } else {
                            resolve([]);
                        }
                    });
                });
            },

            resolveBestCandidate(results, searchTerm, preference = {}) {
                if (!Array.isArray(results) || results.length === 0) {
                    return null;
                }

                const normalizedTerm = this.normalizeString(searchTerm);
                const cityPriority = ['locality', 'sublocality', 'postal_town', 'administrative_area_level_2'];
                const regionPriority = ['administrative_area_level_1', 'administrative_area_level_2', 'administrative_area_level_3'];

                const preferredTypes = preference.preferCity ? cityPriority : regionPriority;
                const secondaryTypes = preference.preferCity ? regionPriority : cityPriority;

                const matchesTerm = results.filter((result) => this.resultMatchesTerm(result, normalizedTerm));

                const matchWithPreferredType = matchesTerm.find((result) => this.resultHasType(result, preferredTypes));
                if (matchWithPreferredType) {
                    return this.buildCandidate(matchWithPreferredType, searchTerm);
                }

                const anyPreferredType = results.find((result) => this.resultHasType(result, preferredTypes));
                if (anyPreferredType) {
                    return this.buildCandidate(anyPreferredType, searchTerm);
                }

                const matchWithSecondaryType = matchesTerm.find((result) => this.resultHasType(result, secondaryTypes));
                if (matchWithSecondaryType) {
                    return this.buildCandidate(matchWithSecondaryType, searchTerm);
                }

                if (matchesTerm.length > 0) {
                    return this.buildCandidate(matchesTerm[0], searchTerm);
                }

                return this.buildCandidate(results[0], searchTerm);
            },

            buildCandidate(result, fallbackLabel) {
                if (!result || !result.geometry) {
                    return null;
                }

                const coordinates = this.extractCoordinates(result.geometry);

                if (!coordinates) {
                    return null;
                }

                return {
                    ...coordinates,
                    label: result.formatted_address || result.name || fallbackLabel
                };
            },

            resultHasType(result, preferredTypes) {
                if (!Array.isArray(preferredTypes) || preferredTypes.length === 0) {
                    return false;
                }

                const types = Array.isArray(result.types) ? result.types : [];
                return types.some((type) => preferredTypes.includes(type));
            },

            resultMatchesTerm(result, normalizedTerm) {
                if (!normalizedTerm) {
                    return false;
                }

                const formattedAddress = this.normalizeString(result.formatted_address);
                if (formattedAddress && formattedAddress.includes(normalizedTerm)) {
                    return true;
                }

                if (result.name && this.normalizeString(result.name).includes(normalizedTerm)) {
                    return true;
                }

                const components = Array.isArray(result.address_components) ? result.address_components : [];
                return components.some((component) => {
                    const longName = this.normalizeString(component.long_name);
                    const shortName = this.normalizeString(component.short_name);
                    return longName === normalizedTerm || shortName === normalizedTerm;
                });
            },

            extractCoordinates(geometry) {
                if (!geometry) {
                    return null;
                }

                if (geometry.location) {
                    const lat = typeof geometry.location.lat === 'function' ? geometry.location.lat() : geometry.location.lat;
                    const lng = typeof geometry.location.lng === 'function' ? geometry.location.lng() : geometry.location.lng;

                    if (!Number.isNaN(lat) && !Number.isNaN(lng)) {
                        return { lat, lng };
                    }
                }

                if (geometry.viewport && typeof geometry.viewport.getCenter === 'function') {
                    const center = geometry.viewport.getCenter();
                    return { lat: center.lat(), lng: center.lng() };
                }

                if (geometry.bounds && typeof geometry.bounds.getCenter === 'function') {
                    const center = geometry.bounds.getCenter();
                    return { lat: center.lat(), lng: center.lng() };
                }

                return null;
            },

            normalizeString(value) {
                return (value || '').toString().trim().toLowerCase();
            },

            async geocodeRegion(regionName) {
                try {
                    const trimmedRegion = regionName.trim();
                    const normalizedRegion = this.normalizeString(trimmedRegion);
                    const queries = [
                        `${trimmedRegion} region, Saudi Arabia`,
                        `${trimmedRegion} province, Saudi Arabia`,
                        `${trimmedRegion} governorate, Saudi Arabia`,
                        `${trimmedRegion}, Saudi Arabia`
                    ];

                    for (const queryText of queries) {
                        const query = encodeURIComponent(queryText);
                        const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${query}&limit=10&addressdetails=1&countrycodes=sa`);
                        const results = await response.json();

                        console.log(`Region search for "${trimmedRegion}" with query "${queryText}":`, results.length, 'results');

                        if (results && results.length > 0) {
                            const bestResult = this.pickBestRegionResult(normalizedRegion, results);

                            if (bestResult) {
                                const coordinates = this.getCoordinatesFromResult(bestResult, true);

                                if (coordinates) {
                                    console.log(`Region result for ${trimmedRegion}: ${bestResult.display_name}`);
                                    console.log(`Coordinates: lat=${coordinates.lat}, lng=${coordinates.lng}`);
                                    console.log(`Type: ${bestResult.type}, Class: ${bestResult.class}, Place Rank: ${bestResult.place_rank}`);
                                    return coordinates;
                                }
                            }
                        }
                    }

                    console.warn(`No suitable region results found for ${trimmedRegion}`);
                    return null;
                } catch (error) {
                    console.error('Geocoding region error:', error);
                    return null;
                }
            },

            pickBestRegionResult(normalizedRegion, results) {
                if (!results || results.length === 0) {
                    return null;
                }

                const preferredAddressTypes = ['state', 'region', 'province', 'governorate', 'state_district'];
                const preferredTypes = ['administrative', 'boundary'];
                const addressKeys = ['state', 'region', 'province', 'county', 'state_district', 'governorate'];

                const addressMatches = (result) => {
                    if (!result.address) {
                        return false;
                    }

                    return addressKeys.some((key) => {
                        if (!result.address[key]) {
                            return false;
                        }

                        return this.normalizeString(result.address[key]) === normalizedRegion;
                    });
                };

                for (const result of results) {
                    if (addressMatches(result) && preferredAddressTypes.includes(result.addresstype)) {
                        return result;
                    }
                }

                for (const result of results) {
                    if (addressMatches(result)) {
                        return result;
                    }
                }

                for (const result of results) {
                    if (preferredAddressTypes.includes(result.addresstype) || preferredTypes.includes(result.type)) {
                        return result;
                    }
                }

                return results[0];
            },

            getCoordinatesFromResult(result, preferBoundingBox = false) {
                if (preferBoundingBox && Array.isArray(result.boundingbox) && result.boundingbox.length === 4) {
                    const [south, north, west, east] = result.boundingbox.map(parseFloat);

                    if (![south, north, west, east].some(Number.isNaN)) {
                        return {
                            lat: (south + north) / 2,
                            lng: (west + east) / 2
                        };
                    }
                }

                const lat = parseFloat(result.lat);
                const lng = parseFloat(result.lon ?? result.lng);

                if (!Number.isNaN(lat) && !Number.isNaN(lng)) {
                    return { lat, lng };
                }

                if (Array.isArray(result.boundingbox) && result.boundingbox.length === 4) {
                    const [south, north, west, east] = result.boundingbox.map(parseFloat);

                    if (![south, north, west, east].some(Number.isNaN)) {
                        return {
                            lat: (south + north) / 2,
                            lng: (west + east) / 2
                        };
                    }
                }

                return null;
            },

            normalizeString(value) {
                return (value || '').toString().trim().toLowerCase();
            },

            async searchAvailableStores(lat, lng) {
                try {
                    const productSku = '<?= $escaper->escapeJs($product->getSku()) ?>';
                    console.log('Searching for stores with product:', productSku, 'at location:', lat, lng);

                    const response = await fetch('/stockavailability/store/availability', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: new URLSearchParams({
                            sku: productSku,
                            latitude: lat,
                            longitude: lng,
                            max_distance: 100
                        })
                    });

                    const data = await response.json();
                    console.log('Store availability response:', data);

                    if (data.success) {
                        this.availableStores = data.stores || [];

                        // Sort stores: in_stock first, then by distance
                        this.availableStores.sort((a, b) => {
                            if (a.stock_status === 'in_stock' && b.stock_status !== 'in_stock') return -1;
                            if (a.stock_status !== 'in_stock' && b.stock_status === 'in_stock') return 1;
                            return a.distance - b.distance;
                        });

                        console.log('Found', this.availableStores.length, 'available stores');
                        console.log('In stock:', this.getStoreCountByStatus('in_stock'));
                        console.log('Backorder:', this.getStoreCountByStatus('backorder'));
                    } else {
                        console.error('Store search failed:', data.message);
                        this.availableStores = [];
                    }

                } catch (error) {
                    console.error('Error searching available stores:', error);
                    this.availableStores = [];
                }
            },

            async useCurrentLocation() {
                if (!navigator.geolocation) {
                    alert('<?= $escaper->escapeJs(__('Location services not supported. Please select a city from the list above.')) ?>');
                    return;
                }

                this.isLoading = true;
                this.searchPerformed = true;
                const currentLocationLabel = '<?= $escaper->escapeJs(__('your current location')) ?>';
                this.searchedLocation = currentLocationLabel;
                this.loadingMessage = '<?= $escaper->escapeJs(__('Getting your location...')) ?>';
                this.cityName = currentLocationLabel;

                try {
                    const position = await new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(resolve, reject, {
                            enableHighAccuracy: true,
                            timeout: 10000,
                            maximumAge: 60000
                        });
                    });

                    console.log('Current location found:', position.coords.latitude, position.coords.longitude);
                    await this.refreshStoresForCoordinates(
                        position.coords.latitude,
                        position.coords.longitude,
                        currentLocationLabel,
                        {
                            maintainLoading: true,
                            keepInput: true,
                            force: true
                        }
                    );
                } catch (error) {
                    console.error('Geolocation error:', error);
                    alert('<?= $escaper->escapeJs(__('Unable to get your location. Please select a city from the list above.')) ?>');
                } finally {
                    this.isLoading = false;
                }
            },

            getDirections(store) {
                const url = `https://www.google.com/maps/dir/?api=1&destination=${store.latitude},${store.longitude}`;
                window.open(url, '_blank');
            }
        };
    }
</script>

<style>
    .animate-spin {
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        from {
            transform: rotate(0deg);
        }

        to {
            transform: rotate(360deg);
        }
    }
</style>