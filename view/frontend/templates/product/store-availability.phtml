<?php

/** @var \Madar\StockAvailability\Block\GoogleMaps $block */
$product = $block->getProduct();
if (!$product) {
    return;
}

$mapsApiKey = $block->getReferrerApiKey();
?>

<script>
    (function() {
        const apiKey = <?= json_encode($mapsApiKey, JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_QUOT | JSON_HEX_AMP); ?>;

        if (!apiKey) {
            console.warn('[StoreAvailability] Google Maps API key is missing');
            return;
        }

        if (window.google && window.google.maps) {
            window._mapsApiReady = Promise.resolve(window.google.maps);
            return;
        }

        if (!window._mapsApiReady) {
            window._mapsApiReady = new Promise(function(resolve, reject) {
                const callbackName = '__onGoogleMapsReady';
                const previousCallback = window[callbackName];

                window[callbackName] = function() {
                    if (typeof previousCallback === 'function') {
                        try {
                            previousCallback();
                        } catch (callbackError) {
                            console.error(callbackError);
                        }
                    }

                    resolve(window.google.maps);
                };

                if (document.querySelector('script[src*="maps.googleapis.com/maps/api/js"]')) {
                    return;
                }

                const script = document.createElement('script');
                script.src = 'https://maps.googleapis.com/maps/api/js'
                    + '?key=' + apiKey
                    + '&libraries=places'
                    + '&callback=' + callbackName;
                script.async = true;
                script.defer = true;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
    })();
</script>

<div x-data="storeAvailabilityComponent({ apiKey: <?= json_encode($mapsApiKey, JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_QUOT | JSON_HEX_AMP); ?> })" x-init="init()" class="store-availability-section border-t pt-6 mt-6">
    <h3 class="text-lg font-semibold mb-4"><?= $escaper->escapeHtml(__('Check availability at stores near you')) ?></h3>

    <!-- Location Search Input -->
    <div class="mb-4">
        <label for="city-search" class="block text-sm font-medium text-gray-700 mb-2">
            <?= $escaper->escapeHtml(__('Select or enter your city or region')) ?>
        </label>

        <!-- Manual Location Input -->
        <div class="flex flex-col sm:flex-row gap-2">
            <input
                type="text"
                id="city-search"
                x-ref="cityInput"
                x-model="cityName"
                @keyup.enter="searchByLocation(cityName)"
                placeholder="<?= $escaper->escapeHtmlAttr(__('Or type city or region name (Arabic or English)')) ?>"
                class="flex-1 form-input border border-gray-300 rounded-md px-3 py-2" />
            <button
                @click="searchByLocation(cityName)"
                :disabled="!cityName.trim() || isLoading"
                class="btn btn-primary px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed w-full sm:w-auto">
                <?= $escaper->escapeHtml(__('Search')) ?>
            </button>
            <button
                @click="useCurrentLocation()"
                :disabled="isLoading"
                class="btn btn-secondary px-4 py-2 border border-gray-300 rounded-md hover:bg-gray-50 disabled:opacity-50 w-full sm:w-auto">
                üìç
            </button>
        </div>
        <p class="text-xs text-gray-500 mt-1">
            <?= $escaper->escapeHtml(__('Type your city or region name to search nearby stores')) ?>
        </p>
    </div>

    <!-- Loading State -->
    <div x-show="isLoading" class="text-center py-6">
        <div class="animate-spin w-6 h-6 border-2 border-gray-300 border-t-blue-600 rounded-full mx-auto mb-2"></div>
        <p class="text-gray-600" x-text="loadingMessage"><?= $escaper->escapeHtml(__('Searching...')) ?></p>
    </div>

    <!-- Search Results Info -->
    <div x-show="searchPerformed && !isLoading && searchedLocation" class="mb-4 p-3 bg-blue-50 rounded-lg">
        <p class="text-sm text-blue-800">
            <strong><?= $escaper->escapeHtml(__('Showing stores near:')) ?></strong>
            <span x-text="searchedLocation"></span>
        </p>
    </div>

    <div x-show="searchPerformed && !isLoading && availableStores.length > 0" class="mb-4 grid grid-cols-1 sm:grid-cols-2 gap-4">
        <div class="bg-green-50 p-3 rounded-lg text-center">
            <div class="text-2xl font-bold text-green-700" x-text="getStoreCountByStatus('in_stock')"></div>
            <div class="text-sm text-green-600"><?= $escaper->escapeHtml(__('Stores with immediate stock')) ?></div>
        </div>
        <div class="bg-yellow-50 p-3 rounded-lg text-center">
            <div class="text-2xl font-bold text-yellow-700" x-text="getStoreCountByStatus('backorder')"></div>
            <div class="text-sm text-yellow-600"><?= $escaper->escapeHtml(__('Stores can order from warehouse')) ?></div>
        </div>
    </div>

    <!-- Available Stores List -->
    <div x-show="!isLoading && availableStores.length > 0" class="space-y-3">
        <h4 class="font-medium text-gray-900 flex items-center gap-2">
            <svg class="w-5 h-5 text-green-600" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
            </svg>
            <?= $escaper->escapeHtml(__('Available at these stores')) ?>
            <span class="text-sm font-normal text-gray-600" x-text="'(' + availableStores.length + ' found)'"></span>
        </h4>

        <!-- Group stores by stock status -->
        <div x-show="getStoresByStatus('in_stock').length > 0" class="mb-4">
            <h5 class="text-sm font-medium text-gray-700 mb-2"><?= $escaper->escapeHtml(__('In Stock at Store')) ?></h5>
            <template x-for="store in getStoresByStatus('in_stock')" :key="store.source_code">
                <div class="border rounded-lg p-4 bg-white shadow-sm hover:shadow-md transition-shadow mb-2">
                    <div class="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-3">
                        <div class="flex-1">
                            <h5 class="font-medium text-gray-900 mb-1" x-text="store.source_name"></h5>
                            <!--<p class="text-sm text-gray-600 mb-2" x-show="store.phone">
                                üìû <span x-text="store.phone"></span>
                            </p>-->
                            <p class="text-sm text-gray-500">
                                üìç <span x-text="store.distance"></span> km away
                            </p>
                        </div>
                        <div class="text-left sm:text-right sm:ml-4">
                            <div class="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800 mb-2">
                                <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                </svg>
                                <?= $escaper->escapeHtml(__('In Stock')) ?>
                            </div>
                            <div>
                                <button
                                    @click="getDirections(store)"
                                    class="text-xs text-blue-600 hover:underline">
                                    <?= $escaper->escapeHtml(__('Get Directions')) ?>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </template>
        </div>

        <div x-show="getStoresByStatus('backorder').length > 0">
            <h5 class="text-sm font-medium text-gray-700 mb-2"><?= $escaper->escapeHtml(__('Available for Order (Ships from Warehouse)')) ?></h5>
            <template x-for="store in getStoresByStatus('backorder')" :key="store.source_code">
                <div class="border rounded-lg p-4 bg-white shadow-sm hover:shadow-md transition-shadow mb-2">
                    <div class="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-3">
                        <div class="flex-1">
                            <h5 class="font-medium text-gray-900 mb-1" x-text="store.source_name"></h5>
                            <!--
                            <p class="text-sm text-gray-600 mb-2" x-show="store.phone">
                                üìû <span x-text="store.phone"></span>
                            </p>-->
                            <p class="text-sm text-gray-500">
                                üìç <span x-text="store.distance"></span> km away
                            </p>
                            <p class="text-xs text-gray-500 italic mt-1">
                                <?= $escaper->escapeHtml(__('This location can order this item from our warehouse')) ?>
                            </p>
                        </div>
                        <div class="text-left sm:text-right sm:ml-4">
                            <div class="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800 mb-2">
                                <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>
                                </svg>
                                <?= $escaper->escapeHtml(__('Backorder')) ?>
                            </div>
                            <div>
                                <button
                                    @click="getDirections(store)"
                                    class="text-xs text-blue-600 hover:underline">
                                    <?= $escaper->escapeHtml(__('Get Directions')) ?>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </template>
        </div>
    </div>

    <!-- No Available Stores Message -->
    <div x-show="!isLoading && searchPerformed && availableStores.length === 0" class="text-center py-8 text-gray-500 bg-gray-50 rounded-lg">
        <svg class="w-12 h-12 mx-auto mb-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"></path>
        </svg>
        <p class="text-lg font-medium mb-2"><?= $escaper->escapeHtml(__('No stores found with this product in stock')) ?></p>
        <p class="text-sm">
            <?= $escaper->escapeHtml(__('This product is not available at stores near')) ?>
            <span x-text="searchedLocation" class="font-medium"></span>
        </p>
        <p class="text-xs mt-2"><?= $escaper->escapeHtml(__('Try searching for a different city or check online availability.')) ?></p>
    </div>
</div>

<script>
    function storeAvailabilityComponent(config = {}) {
        return {
            apiKey: config.apiKey || '',
            mapsApi: null,
            geocoder: null,
            placesService: null,
            mapsHelperElement: null,
            mapsLoadError: false,
            availableStores: [],
            searchPerformed: false,
            isLoading: false,
            cityName: '',
            searchedLocation: '',
            loadingMessage: '<?= $escaper->escapeJs(__('Searching...')) ?>',

            init() {
                console.log('Store availability component initialized');

                if (this.apiKey) {
                    this.ensureMapsApi().catch((error) => {
                        console.error('Failed to prepare Google Maps services', error);
                    });
                } else {
                    console.warn('[StoreAvailability] Google Maps API key missing ‚Äì geocoding will be unavailable');
                }
            },

            async ensureMapsApi() {
                if (this.mapsApi) {
                    return this.mapsApi;
                }

                if (!window._mapsApiReady) {
                    this.mapsLoadError = true;
                    return null;
                }

                try {
                    const maps = await window._mapsApiReady;
                    this.mapsApi = maps;
                    this.mapsLoadError = false;

                    if (!this.geocoder) {
                        this.geocoder = new maps.Geocoder();
                    }

                    if (!this.placesService && maps.places) {
                        this.mapsHelperElement = this.mapsHelperElement || document.createElement('div');
                        this.placesService = new maps.places.PlacesService(this.mapsHelperElement);
                    }

                    return maps;
                } catch (error) {
                    this.mapsLoadError = true;
                    console.error('[StoreAvailability] Failed to load Google Maps API', error);
                    return null;
                }
            },

            // Add new method to filter stores by status
            getStoresByStatus(status) {
                return this.availableStores.filter(store => store.stock_status === status);
            },

            // Add method to count stores by type
            getStoreCountByStatus(status) {
                return this.getStoresByStatus(status).length;
            },

            async searchByLocation(placeName) {
                if (!placeName || !placeName.trim()) {
                    alert('<?= $escaper->escapeJs(__('Please enter a city or region name')) ?>');
                    return;
                }

                const trimmedName = placeName.trim();

                this.isLoading = true;
                this.searchPerformed = true;
                this.availableStores = [];
                this.searchedLocation = trimmedName;
                this.loadingMessage = '<?= $escaper->escapeJs(__('Finding location...')) ?>';

                try {
                    if (!this.apiKey) {
                        throw new Error('Google Maps API key not configured');
                    }

                    const maps = await this.ensureMapsApi();

                    if (!maps || this.mapsLoadError) {
                        throw new Error('Google Maps API unavailable');
                    }

                    let coordinates = await this.geocodeCity(trimmedName);

                    if (!coordinates) {
                        console.warn(`No city match found for ${trimmedName}, trying region search...`);
                        this.loadingMessage = '<?= $escaper->escapeJs(__('Finding region...')) ?>';
                        coordinates = await this.geocodeRegion(trimmedName);
                    }

                    if (coordinates) {
                        this.loadingMessage = '<?= $escaper->escapeJs(__('Searching for available stores...')) ?>';
                        this.searchedLocation = coordinates.label || trimmedName;
                        await this.searchAvailableStores(coordinates.lat, coordinates.lng);
                    } else {
                        this.availableStores = [];
                        alert('<?= $escaper->escapeJs(__('Location not found. Please check the spelling and try again.')) ?>');
                    }

                } catch (error) {
                    console.error('Error searching by location:', error);
                    this.availableStores = [];
                    alert('<?= $escaper->escapeJs(__('Error searching for stores. Please try again.')) ?>');
                } finally {
                    this.isLoading = false;
                }
            },

            async geocodeCity(cityName) {
                try {
                    await this.ensureMapsApi();

                    const queries = [
                        `${cityName} city, Saudi Arabia`,
                        `${cityName}, Saudi Arabia`
                    ];

                    const geocodeResults = await this.geocodeWithQueries(queries);
                    const cityCandidate = this.resolveBestCandidate(geocodeResults, cityName, { preferCity: true });

                    if (cityCandidate) {
                        return cityCandidate;
                    }

                    const placesResults = await this.findPlaces(queries, { preferCity: true });
                    return this.resolveBestCandidate(placesResults, cityName, { preferCity: true });
                } catch (error) {
                    console.error('Geocoding error:', error);
                    return null;
                }
            },

            async geocodeRegion(regionName) {
                try {
                    await this.ensureMapsApi();

                    const queries = [
                        `${regionName} region, Saudi Arabia`,
                        `${regionName} province, Saudi Arabia`,
                        `${regionName} governorate, Saudi Arabia`,
                        `${regionName}, Saudi Arabia`
                    ];

                    const geocodeResults = await this.geocodeWithQueries(queries);
                    const regionCandidate = this.resolveBestCandidate(geocodeResults, regionName, { preferRegion: true });

                    if (regionCandidate) {
                        return regionCandidate;
                    }

                    const placesResults = await this.findPlaces(queries, { preferRegion: true });
                    return this.resolveBestCandidate(placesResults, regionName, { preferRegion: true });
                } catch (error) {
                    console.error('Geocoding region error:', error);
                    return null;
                }
            },

            async geocodeWithQueries(queries) {
                if (!this.geocoder || !Array.isArray(queries)) {
                    return [];
                }

                const combinedResults = [];

                for (const query of queries) {
                    const results = await this.runGeocode({
                        address: query,
                        componentRestrictions: { country: 'SA' }
                    });

                    if (results.length) {
                        combinedResults.push(...results);
                    }

                    if (combinedResults.length) {
                        break;
                    }
                }

                return combinedResults;
            },

            async findPlaces(queries, preference = {}) {
                if (!this.placesService || !Array.isArray(queries)) {
                    return [];
                }

                const combinedResults = [];

                for (const query of queries) {
                    const results = await this.runPlacesQuery(query);

                    if (results.length) {
                        combinedResults.push(...results);
                    }

                    if (combinedResults.length) {
                        break;
                    }
                }

                return combinedResults;
            },

            runGeocode(request) {
                return new Promise((resolve) => {
                    if (!this.geocoder) {
                        resolve([]);
                        return;
                    }

                    this.geocoder.geocode(request, (results, status) => {
                        if (status === 'OK' && Array.isArray(results)) {
                            resolve(results);
                        } else {
                            resolve([]);
                        }
                    });
                });
            },

            runPlacesQuery(query) {
                return new Promise((resolve) => {
                    if (!this.placesService) {
                        resolve([]);
                        return;
                    }

                    const request = {
                        query,
                        fields: ['name', 'geometry', 'formatted_address', 'types']
                    };

                    this.placesService.findPlaceFromQuery(request, (results, status) => {
                        const maps = this.mapsApi;
                        const okStatus = maps && maps.places ? maps.places.PlacesServiceStatus.OK : 'OK';

                        if (status === okStatus && Array.isArray(results)) {
                            resolve(results);
                        } else {
                            resolve([]);
                        }
                    });
                });
            },

            resolveBestCandidate(results, searchTerm, preference = {}) {
                if (!Array.isArray(results) || results.length === 0) {
                    return null;
                }

                const normalizedTerm = this.normalizeString(searchTerm);
                const cityPriority = ['locality', 'sublocality', 'postal_town', 'administrative_area_level_2'];
                const regionPriority = ['administrative_area_level_1', 'administrative_area_level_2', 'administrative_area_level_3'];

                const preferredTypes = preference.preferCity ? cityPriority : regionPriority;
                const secondaryTypes = preference.preferCity ? regionPriority : cityPriority;

                const matchesTerm = results.filter((result) => this.resultMatchesTerm(result, normalizedTerm));

                const matchWithPreferredType = matchesTerm.find((result) => this.resultHasType(result, preferredTypes));
                if (matchWithPreferredType) {
                    return this.buildCandidate(matchWithPreferredType, searchTerm);
                }

                const anyPreferredType = results.find((result) => this.resultHasType(result, preferredTypes));
                if (anyPreferredType) {
                    return this.buildCandidate(anyPreferredType, searchTerm);
                }

                const matchWithSecondaryType = matchesTerm.find((result) => this.resultHasType(result, secondaryTypes));
                if (matchWithSecondaryType) {
                    return this.buildCandidate(matchWithSecondaryType, searchTerm);
                }

                if (matchesTerm.length > 0) {
                    return this.buildCandidate(matchesTerm[0], searchTerm);
                }

                return this.buildCandidate(results[0], searchTerm);
            },

            buildCandidate(result, fallbackLabel) {
                if (!result || !result.geometry) {
                    return null;
                }

                const coordinates = this.extractCoordinates(result.geometry);

                if (!coordinates) {
                    return null;
                }

                return {
                    ...coordinates,
                    label: result.formatted_address || result.name || fallbackLabel
                };
            },

            resultHasType(result, preferredTypes) {
                if (!Array.isArray(preferredTypes) || preferredTypes.length === 0) {
                    return false;
                }

                const types = Array.isArray(result.types) ? result.types : [];
                return types.some((type) => preferredTypes.includes(type));
            },

            resultMatchesTerm(result, normalizedTerm) {
                if (!normalizedTerm) {
                    return false;
                }

                const formattedAddress = this.normalizeString(result.formatted_address);
                if (formattedAddress && formattedAddress.includes(normalizedTerm)) {
                    return true;
                }

                if (result.name && this.normalizeString(result.name).includes(normalizedTerm)) {
                    return true;
                }

                const components = Array.isArray(result.address_components) ? result.address_components : [];
                return components.some((component) => {
                    const longName = this.normalizeString(component.long_name);
                    const shortName = this.normalizeString(component.short_name);
                    return longName === normalizedTerm || shortName === normalizedTerm;
                });
            },

            extractCoordinates(geometry) {
                if (!geometry) {
                    return null;
                }

                if (geometry.location) {
                    const lat = typeof geometry.location.lat === 'function' ? geometry.location.lat() : geometry.location.lat;
                    const lng = typeof geometry.location.lng === 'function' ? geometry.location.lng() : geometry.location.lng;

                    if (!Number.isNaN(lat) && !Number.isNaN(lng)) {
                        return { lat, lng };
                    }
                }

                if (geometry.viewport && typeof geometry.viewport.getCenter === 'function') {
                    const center = geometry.viewport.getCenter();
                    return { lat: center.lat(), lng: center.lng() };
                }

                if (geometry.bounds && typeof geometry.bounds.getCenter === 'function') {
                    const center = geometry.bounds.getCenter();
                    return { lat: center.lat(), lng: center.lng() };
                }

                return null;
            },

            normalizeString(value) {
                return (value || '').toString().trim().toLowerCase();
            },

            async searchAvailableStores(lat, lng) {
                try {
                    const productSku = '<?= $escaper->escapeJs($product->getSku()) ?>';
                    console.log('Searching for stores with product:', productSku, 'at location:', lat, lng);

                    const response = await fetch('/stockavailability/store/availability', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: new URLSearchParams({
                            sku: productSku,
                            latitude: lat,
                            longitude: lng,
                            max_distance: 100
                        })
                    });

                    const data = await response.json();
                    console.log('Store availability response:', data);

                    if (data.success) {
                        this.availableStores = data.stores || [];

                        // Sort stores: in_stock first, then by distance
                        this.availableStores.sort((a, b) => {
                            if (a.stock_status === 'in_stock' && b.stock_status !== 'in_stock') return -1;
                            if (a.stock_status !== 'in_stock' && b.stock_status === 'in_stock') return 1;
                            return a.distance - b.distance;
                        });

                        console.log('Found', this.availableStores.length, 'available stores');
                        console.log('In stock:', this.getStoreCountByStatus('in_stock'));
                        console.log('Backorder:', this.getStoreCountByStatus('backorder'));
                    } else {
                        console.error('Store search failed:', data.message);
                        this.availableStores = [];
                    }

                } catch (error) {
                    console.error('Error searching available stores:', error);
                    this.availableStores = [];
                }
            },

            async useCurrentLocation() {
                if (!navigator.geolocation) {
                    alert('<?= $escaper->escapeJs(__('Location services not supported. Please select a city from the list above.')) ?>');
                    return;
                }

                this.isLoading = true;
                this.searchPerformed = true;
                this.searchedLocation = '<?= $escaper->escapeJs(__('your current location')) ?>';
                this.loadingMessage = '<?= $escaper->escapeJs(__('Getting your location...')) ?>';

                try {
                    const position = await new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(resolve, reject, {
                            enableHighAccuracy: true,
                            timeout: 10000,
                            maximumAge: 60000
                        });
                    });

                    console.log('Current location found:', position.coords.latitude, position.coords.longitude);
                    this.loadingMessage = '<?= $escaper->escapeJs(__('Searching for available stores...')) ?>';

                    await this.searchAvailableStores(position.coords.latitude, position.coords.longitude);
                } catch (error) {
                    console.error('Geolocation error:', error);
                    alert('<?= $escaper->escapeJs(__('Unable to get your location. Please select a city from the list above.')) ?>');
                } finally {
                    this.isLoading = false;
                }
            },

            getDirections(store) {
                const url = `https://www.google.com/maps/dir/?api=1&destination=${store.latitude},${store.longitude}`;
                window.open(url, '_blank');
            }
        };
    }
</script>

<style>
    .animate-spin {
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        from {
            transform: rotate(0deg);
        }

        to {
            transform: rotate(360deg);
        }
    }
</style>